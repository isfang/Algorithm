# Algorithm

## heap

堆可以实现一个优先队列, 可以用一颗树表示,``子节点都不能大于其根节点``,最简单的堆可以使用数组存放,然后在插入书时按照子节点都不能大于其根节的要求插入

* insert操作

  每一次插入都是把元素插入到数组的最后,然后对这个数据进行shift up操

  ```markdown
  shift up

  //向上移动元素
  //新的数据总是加在最后一个,所以就是外面传进来的k这个元素
  //调整这个新加入的元素,调整到合适的位置,每次都跟父节点比大小,如果比父节点大就交换位置
  //直到调整到合适的位置,父节点的位置就是当前index/2
  void shiftUp(int k) {
      while(k > 1 && data[k/2] < data[k]) {
          swap(data[k/2], data[k]);
          k /= 2;
      }
  }
  ```

* 取出堆中,权重最大的值,并且调整堆,也就是取出第一个元素,然后把最后一个元素放到第一个元素的位置,count -- ,然后再针对,第一个元素做shift down 的操作

  堆排序也是同样的道理,不停的取出第一个元素, 调整堆再取第一个元素

  ```
  shift down

  //向下移动元素
  //下一个元素的index值为2*index,所以只需要比较index 与2*index 还有 2*index + 1的大小就可以了
  //如果index<2*index,那么交换位置,继续比较
  //跟左右孩子比,谁大跟谁换

  void shiftDown(int k) {

      //k这个元素有左孩子的话
      while(count >= 2*k) {
          //j与j+1表示将要被比较的元素的位置,就是k元素的左右孩子
          int j = 2*k;

          //j+1就是右孩子,j+1 <= count 说明有右孩子
          //先看右孩子跟左孩子谁大
          //如果是右孩子大的话,把j更新成j+1
          if(j+1 <= count && data[j+1] > data[j]){
              ++j;
          }

          //目前 j就是左右孩子中最大的一个

          //如果k本来就比左右孩子都大,那么啥都不干就可以
          if(data[k]>=data[j]) {
              break;
          }

          swap(data[k], data[j]);
          k=j;
      }
  }
  ```

* heapify操作

  用于生成一个堆的时候,区别于最简单的方式, 直接针对一个数组执行heapify操作生成堆,而不是一个一个的shiftup操作

  除去全部的没有孩子的叶子节点,然后遍历,挨个执行shiftdown的操作,heapify全部的数据,也就是都进行一遍shiftdown的操作

  ```
  //执行heapify操作
  //count/2; 这个值正好是除去全部的叶子节点,剩下的最大的一个不是节点的堆
  //然后遍历,执行shiftdown的操作就可以将全部的数据都进行一遍shiftdown的操作
  for (int i = count/2; i >=1 ; --i) {
      shiftDown(i);
  }
  ```

* 索引堆

  不直接交换数组,交换数组的索引,在创建堆的时候,创建一个数组存放索引,这样就可以,操作索引,而不是数组本身,避免交换产生的消耗